(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const g of a.addedNodes)g.tagName==="LINK"&&g.rel==="modulepreload"&&i(g)}).observe(document,{childList:!0,subtree:!0});function e(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(r){if(r.ep)return;r.ep=!0;const a=e(r);fetch(r.href,a)}})();const f=document.createElement("template");f.innerHTML=`
<canvas id="chart"></canvas>
`;const T=document.createElement("template");T.innerHTML=`
<style>

canvas {
  box-sizing: border-box;
  border: 1px solid black;
}

</style>
`;class n{_x=0;_y=0;constructor(t,e){this.validateNumber(t),this.validateNumber(e),this._x=t,this._y=e}get x(){return this._x}get y(){return this._y}validateNumber(t){if(typeof t!="number")throw new TypeError("argument must be number")}}class d{_top=0;_left=0;_right=0;_bottom=0;constructor(t,e){this.validatePoint(t),this.validatePoint(e),this._top=t.y,this._left=t.x,this._bottom=e.y,this._right=e.x}get topLeft(){return new n(this.left,this.top)}get topRight(){return new n(this.right,this.top)}get bottomRight(){return new n(this.right,this.bottom)}get bottomLeft(){return new n(this.left,this.bottom)}get top(){return this._top}get right(){return this._right}get bottom(){return this._bottom}get left(){return this._left}get width(){return this.right-this.left}get height(){return this.bottom-this.top}validatePoint(t){if(!(t instanceof n))throw new TypeError("argument not of type Point")}}class l{_start;_end;constructor(t,e){this._start=t,this._end=e}get start(){return this._start}get end(){return this._end}get length(){const t=this.end.x-this.start.x,e=this.end.y-this.start.y;return Math.hypot(t,e)}}class w{source;target;constructor(t,e){this.source=t,this.target=e}mapPoint(t){const e=this.translatePointFromSource(t),i=this.scalePointToTarget(e);return this.translatePointToTarget(i)}translatePointFromSource(t){return new n(t.x-this.source.left,t.y-this.source.top)}scalePointToTarget(t){return new n(t.x/this.source.width*this.target.width,t.y/this.source.height*this.target.height)}translatePointToTarget(t){return new n(t.x+this.target.left,t.y+this.target.top)}reverseMapPoint(t){const e=this.translatePointFromTarget(t),i=this.scalePointToSource(e);return this.translatePointToSource(i)}translatePointFromTarget(t){return new n(t.x-this.target.left,t.y-this.target.top)}scalePointToSource(t){return new n(t.x/this.target.width*this.source.width,t.y/this.target.height*this.source.height)}translatePointToSource(t){return new n(t.x+this.source.left,t.y+this.source.top)}mapRectangle(t){const e=this.mapPoint(t.topLeft),i=this.mapPoint(t.bottomRight);return new d(e,i)}reverseMapRectangle(t){const e=this.reverseMapPoint(t.topLeft),i=this.reverseMapPoint(t.bottomRight);return new d(e,i)}mapLineSegment(t){return new l(this.mapPoint(t.start),this.mapPoint(t.end))}reverseMapLineSegment(t){return new l(this.reverseMapPoint(t.start),this.reverseMapPoint(t.end))}}class L{canvasWidth=0;canvasHeight=0}const c=35;class C extends L{_lines=[];_scaleInterval=50;_paddingX=0;_paddingY=0;_viewport=null;_boundingBoxOfLines=this.calculateBoundingBoxOfLines();constructor(){super()}addLine(t){this._lines.push(t),this._boundingBoxOfLines=this.calculateBoundingBoxOfLines()}clearLines(){this._lines=[],this._boundingBoxOfLines=this.calculateBoundingBoxOfLines()}calculateBoundingBoxOfLines(){let t=new n(1/0,-1/0),e=new n(-1/0,1/0);for(const i of this.lines.flatMap(r=>r.points))t=new n(Math.min(i.x,t.x),Math.max(i.y,t.y)),e=new n(Math.max(i.x,e.x),Math.min(i.y,e.y));return new d(t,e)}get lines(){return this._lines}get boundingBoxOfLines(){return this._boundingBoxOfLines}set viewport(t){this._viewport=t}get viewport(){return this._viewport===null&&this.autoFit(),this._viewport}autoFit(t={}){this.paddingX=t.paddingX??0,this.paddingY=t.paddingY??0;const e=new w(this.boundingBoxOfLines,this.pixelViewportMinusPadding);this.viewport=e.reverseMapRectangle(this.pixelViewport)}set axisTickInterval(t){if(typeof t!="number"||t<=0||!Number.isFinite(t))throw new TypeError("scale interval must be a positive number");this._scaleInterval=t}get axisTickInterval(){return this._scaleInterval}set paddingX(t){if(typeof t!="number"||t<0||!Number.isFinite(t))throw new TypeError("padding must be a non-negative number");this._paddingX=t}get paddingX(){return this._paddingX}set paddingY(t){if(typeof t!="number"||t<0||!Number.isFinite(t))throw new TypeError("padding must be a non-negative number");this._paddingY=t}get paddingY(){return this._paddingY}get pixelViewportMinusPadding(){const t=c+this.paddingX,e=this.paddingY,i=this.canvasWidth-this.paddingX,r=this.canvasHeight-c-this.paddingY;return new d(new n(t,e),new n(i,r))}get pixelViewport(){const t=c,e=0,i=this.canvasWidth,r=this.canvasHeight-c;return new d(new n(t,e),new n(i,r))}get chartToScreenMapper(){return new w(this.viewport,this.pixelViewport)}}class m{start;end;constructor(t=0,e=1){this.validateNumber(t),this.validateNumber(e),this.start=t,this.end=e}validateNumber(t){if(typeof t!="number")throw new TypeError("argument must be number")}get length(){return this.end-this.start}}const h=35,p=h*.2,u=p+h*.1;var o;(function(s){s[s.X=0]="X",s[s.Y=1]="Y"})(o||(o={}));class _{renderingContext;chartState;constructor(t,e){this.renderingContext=t,this.chartState=e}render(){this.clear(),this.drawGrid(),this.drawLines(),this.drawSideMargins(),this.drawOutline(),this.drawAxes()}clear(){this.resetRenderingContext(),this.fillBackground()}resetRenderingContext(){this.renderingContext.reset(),this.renderingContext.save()}resetStyle(){this.renderingContext.restore(),this.renderingContext.save()}fillBackground(){this.renderingContext.fillStyle="white",this.renderingContext.fillRect(0,0,this.renderingContext.canvas.width,this.renderingContext.canvas.height)}drawGrid(){const t=this.getTickGeneratorFromAxis(o.X);this.drawGridLines(t,o.X);const e=this.getTickGeneratorFromAxis(o.Y);this.drawGridLines(e,o.Y)}getTickGeneratorFromAxis(t){return this.generateTickPositions(this.getViewportRangeAlongAxis(t),this.getGoalNumberOfTicksAlongAxis(t))}getViewportRangeAlongAxis(t){if(t===o.X)return this.getViewportRangeAlongX();if(t===o.Y)return this.getViewportRangeAlongY();throw new TypeError("invalid axis")}getViewportRangeAlongX(){return new m(this.chartState.viewport.left,this.chartState.viewport.right)}getViewportRangeAlongY(){return new m(this.chartState.viewport.bottom,this.chartState.viewport.top)}getGoalNumberOfTicksAlongAxis(t){return this.getPixelViewportSizeAlongAxis(t)/this.chartState.axisTickInterval}getPixelViewportSizeAlongAxis(t){if(t===o.X)return this.chartState.pixelViewport.width;if(t===o.Y)return this.chartState.pixelViewport.height;throw new TypeError("invalid axis")}*generateTickPositions(t,e){const i=t.length/e,r=this.roundToNiceTickInterval(i);for(let a=Math.ceil(t.start/r)*r;a<=t.end;a+=r)yield a}roundToNiceTickInterval(t){const e=this.getPossibleTickIntervals(t);return this.getClosestNumberInArray(t,e)}getPossibleTickIntervals(t){const e=this.getClosestPowerOfTen(t);return[e,e*2,e*5]}getClosestPowerOfTen(t){return Math.pow(10,Math.floor(Math.log10(t)))}getClosestNumberInArray(t,e){return e.reduce((i,r)=>Math.abs(t-r)<Math.abs(t-i)?r:i)}drawGridLines(t,e){for(let i=t.next().value;i!==void 0;i=t.next().value)this.drawGridLine(i,e)}drawGridLine(t,e){const i=this.getPixelGridLineSegment(t,e);this.setGridLineStyle(),this.drawLineSegment(i)}getPixelGridLineSegment(t,e){const i=this.getGridLineSegment(t,e);return this.chartState.chartToScreenMapper.mapLineSegment(i)}getGridLineSegment(t,e){if(e===o.X)return this.getGridLineSegmentOnX(t);if(e===o.Y)return this.getGridLineSegmentOnY(t);throw new TypeError("invalid axis")}getGridLineSegmentOnX(t){return new l(new n(t,this.chartState.viewport.bottom),new n(t,this.chartState.viewport.top))}getGridLineSegmentOnY(t){return new l(new n(this.chartState.viewport.left,t),new n(this.chartState.viewport.right,t))}setGridLineStyle(){this.resetStyle(),this.renderingContext.strokeStyle="#e0e0e0"}drawLineSegment(t){this.drawLineBetweenPoints(t.start,t.end)}drawLineBetweenPoints(t,e){this.renderingContext.beginPath(),this.renderingContext.moveTo(t.x,t.y),this.renderingContext.lineTo(e.x,e.y),this.renderingContext.stroke()}drawLines(){for(const t of this.chartState.lines)this.drawLine(t)}drawLine(t){this.setChartLineStyle(t),this.renderingContext.beginPath();for(const e of t.points){const i=this.chartState.chartToScreenMapper.mapPoint(e);this.renderingContext.lineTo(i.x,i.y)}this.renderingContext.stroke()}setChartLineStyle(t){this.resetStyle(),this.renderingContext.strokeStyle=t.color.toString(),this.renderingContext.lineWidth=t.thickness,this.renderingContext.lineCap="round",this.renderingContext.lineJoin="round"}drawSideMargins(){this.drawLeftMargin(),this.drawBottomMargin()}drawLeftMargin(){this.resetStyle(),this.renderingContext.fillStyle="white",this.renderingContext.fillRect(0,0,h,this.renderingContext.canvas.height)}drawBottomMargin(){this.resetStyle(),this.renderingContext.fillStyle="white",this.renderingContext.fillRect(0,this.renderingContext.canvas.height-h,this.renderingContext.canvas.width,h)}drawOutline(){this.resetStyle(),this.drawRectangle(this.chartState.pixelViewport)}drawRectangle(t){this.renderingContext.beginPath(),this.renderingContext.rect(t.left,t.top,t.width,t.height),this.renderingContext.stroke()}drawAxes(){const t=this.getTickGeneratorFromAxis(o.X);this.drawAxis(t,o.X);const e=this.getTickGeneratorFromAxis(o.Y);this.drawAxis(e,o.Y)}drawAxis(t,e){for(let i=t.next().value;i!==void 0;i=t.next().value)this.resetStyle(),this.drawTickAndLabel(i,e)}drawTickAndLabel(t,e){const i=this.getTickPosition(t,e);this.drawTick(i,e);const r=this.getTickLabelPosition(i,e),a=this.numberToString(t);this.setAxisLabelStyle(a,e),this.drawTickLabel(r,a)}setAxisLabelStyle(t,e){this.renderingContext.fillStyle="black",this.renderingContext.font=`${this.getLabelFont(t,h-u)}px Arial`,this.renderingContext.textAlign=e===o.X?"center":"right",this.renderingContext.textBaseline=e===o.X?"top":"middle"}getLabelFont(t,e){let i=13;for(this.renderingContext.font=`${i}px Arial`;this.renderingContext.measureText(t).width>e;)i-=.1,this.renderingContext.font=`${i}px Arial`;return i}getTickPosition(t,e){let i;return e===o.X?i=new n(t,this.chartState.viewport.bottom):i=new n(this.chartState.viewport.left,t),this.chartState.chartToScreenMapper.mapPoint(i)}drawTick(t,e){let i;e===o.X?i=new n(t.x,t.y+p):i=new n(t.x-p,t.y),this.drawLineBetweenPoints(t,i)}getTickLabelPosition(t,e){let i;return e===o.X?i=new n(t.x,t.y+u):i=new n(t.x-u,t.y),i}numberToString(t){return this.roundToDecimalPlaces(t,10).toString()}roundToDecimalPlaces(t,e){return parseFloat(t.toFixed(e))}drawTickLabel(t,e){this.renderingContext.fillText(e,t.x,t.y)}}const x="line-chart";class b extends HTMLElement{chart=null;renderingContext=null;state=new C;renderer=null;_width=500;_height=500;constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot?.appendChild(f.content.cloneNode(!0)),this.shadowRoot?.appendChild(T.content.cloneNode(!0)),this.updateCanvasSize()}async connectedCallback(){this.chart=this.shadowRoot.querySelector("#chart")??null,this.updateCanvasSize(),this.chart&&(this.renderingContext=this.chart.getContext("2d"),this.renderer=new _(this.renderingContext,this.state),this.renderer.render())}disconnectedCallback(){}attributeChangedCallback(t,e,i){if(e!==i)switch(t){case"axisTickInterval":this.axisTickInterval=i;break;case"width":this.width=i;break;case"height":this.height=i;break}}static get observedAttributes(){return["axisTickInterval","width","height"]}addLine(t){this.state.addLine(t),this.renderer?.render()}clearLines(){this.state.clearLines(),this.renderer?.render()}setViewport(t){this.state.viewport=t,this.renderer?.render()}autoFitViewport(t={}){this.state.autoFit(t),this.renderer?.render()}set axisTickInterval(t){this.state.axisTickInterval=Number(t),this.renderer?.render()}get width(){return this._width}set width(t){const e=Number(t);if(!Number.isFinite(e)||e<=0)throw new TypeError("width must be a positive number");this._width=e,this.updateCanvasSize()}get height(){return this._height}set height(t){const e=Number(t);if(!Number.isFinite(e)||e<=0)throw new TypeError("height must be a positive number");this._height=e,this.updateCanvasSize()}updateCanvasSize(){this.state.canvasWidth=this.width,this.state.canvasHeight=this.height,this.chart&&(this.chart.width=this.width,this.chart.height=this.height,this.renderer?.render())}}customElements.get(x)||customElements.define(x,b);class y{cssColor;constructor(t="black"){this.cssColor=t}toString(){return this.cssColor}}class P{_points;_color;_thickness;constructor(t=[],e){for(const i of t)if(!(i instanceof n))throw new TypeError("input array contains non-Point element");this._points=Array.from(t),this._color=e?.color??new y,this._thickness=e?.thickness??1}get points(){return this._points}get color(){return this._color}get thickness(){return this._thickness}}const S=[];for(let s=0;s<=10;s+=.1){const t=Math.sin(s);S.push(new n(s,t))}const v=new b;v.addLine(new P(S,{color:new y("blue"),thickness:3}));document.body.appendChild(v);
